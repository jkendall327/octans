@inject ShellService ShellService
@inject IDialogService DialogService
@implements IDisposable

<div class="image-viewer"
     tabindex="0"
     @ref="_root"
     @onkeydown="@OnKeyDown"
>
    <section class="toolbar">
        <MudButton
            OnClick="@(OnClose)"
            Size="Size.Small"
            Class="mr-n3 mb-1"
            Color="Color.Error">
            Close
        </MudButton>
        <MudButton
            OnClick="@(PreviousAsync)"
            Disabled="@(CurrentImage is null)"
            Size="Size.Small"
            Class="mr-n3 mb-1"
            Color="Color.Default">
            Previous
        </MudButton>
        @if (FilterMode)
        {
            <MudButton
                OnClick="@(ArchiveAsync)"
                Disabled="@(CurrentImage is null)"
                Size="Size.Small"
                Class="mr-n3 mb-1"
                Color="Color.Success">
                Archive
            </MudButton>

            <MudButton
                OnClick="@(DeleteAsync)"
                Disabled="@(CurrentImage is null)"
                Size="Size.Small"
                Class="mr-n3 mb-1"
                Color="Color.Error">
                Delete
            </MudButton>
        }
        <MudButton
            OnClick="@(NextAsync)"
            Disabled="@(CurrentImage is null)"
            Size="Size.Small"
            Class="mr-n3 mb-1"
            Color="Color.Default">
            Next
        </MudButton>
    </section>

    <section class="media-plane" @ondblclick="@OnClose">
        <div class="tag-list">
            <!-- TODO: get actual tags. -->
            <p>foo</p>
            <p>foo</p>
            <p>foo</p>
            <p>foo</p>
            <p>foo</p>
            <p>foo</p>
            <p>foo</p>
            <p>foo</p>
        </div>
        <div class="image-display" @onmousedown="@OnImageMouseDown" @oncontextmenu:preventDefault>
            @if (CurrentImage is null)
            {
                <p>Loading...</p>
            }
            else
            {
                <img
                    src="@CurrentImage"
                    alt="Gallery image"
                    loading="lazy"
                    decoding="async"
                    referrerpolicy="no-referrer"/>
            }
        </div>
    </section>
</div>


@code {
    private ElementReference _root;
    private bool _shouldFocus;

    [Parameter, EditorRequired] public List<string> ImageUrls { get; set; } = [];
    [Parameter] public string? StartingImage { get; set; }
    [Parameter] public EventCallback<string> CurrentImageChanged { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public bool FilterMode { get; set; }
    [Parameter] public EventCallback<FilterResult> OnFilterComplete { get; set; }

    private string? CurrentImage { get; set; }
    private Dictionary<string, FilterChoice> _choices = [];

    protected override void OnParametersSet()
    {
        CurrentImage = StartingImage ?? ImageUrls.First();
        _shouldFocus = true;

        if (FilterMode)
        {
            _choices = [];
        }

        ShellService.HideShell();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldFocus)
        {
            _shouldFocus = false;
            await _root.FocusAsync();
        }
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowLeft": await PreviousAsync(); break;
            case "ArrowRight": await NextAsync(); break;
            case "Escape":
                if (FilterMode)
                {
                    await PromptCommitAsync();
                }
                else
                {
                    await OnClose.InvokeAsync();
                }

                break;
        }
    }

    private async Task PreviousAsync()
    {
        if (CurrentImage is null)
        {
            throw new InvalidOperationException("Current image was null after parameters being set");
        }

        var idx = ImageUrls.IndexOf(CurrentImage);

        var prev = idx - 1;

        CurrentImage = IsValidIndex(ImageUrls, prev) ? ImageUrls[prev] : ImageUrls.Last();

        await CurrentImageChanged.InvokeAsync(CurrentImage);
    }

    private async Task NextAsync()
    {
        if (CurrentImage is null)
        {
            throw new InvalidOperationException("Current image was null after parameters being set");
        }

        var idx = ImageUrls.IndexOf(CurrentImage);

        var next = idx + 1;

        CurrentImage = IsValidIndex(ImageUrls, next) ? ImageUrls[next] : ImageUrls.First();

        await CurrentImageChanged.InvokeAsync(CurrentImage);
    }

    private async Task ArchiveAsync()
    {
        await RecordChoiceAsync(FilterChoice.Archive);
    }

    private async Task DeleteAsync()
    {
        await RecordChoiceAsync(FilterChoice.Delete);
    }

    private async Task RecordChoiceAsync(FilterChoice choice)
    {
        if (CurrentImage is null)
        {
            throw new InvalidOperationException("Current image was null after parameters being set");
        }

        _choices[CurrentImage] = choice;

        var allImagesJudged = _choices.Count == ImageUrls.Count;
        var onLastImage = ImageUrls.IndexOf(CurrentImage) == ImageUrls.Count - 1;

        if (allImagesJudged || onLastImage)
        {
            await PromptCommitAsync(undoLast: true);
        }
        else
        {
            await NextAsync();
        }
    }

    private async Task OnImageMouseDown(MouseEventArgs e)
    {
        if (!FilterMode || CurrentImage is null)
        {
            return;
        }

        switch (e.Button)
        {
            case 0:
                await ArchiveAsync();

                break;
            case 1:
                await PreviousAsync();

                break;
            case 2:
                await DeleteAsync();

                break;
        }
    }

    private async Task PromptCommitAsync(bool undoLast = false)
    {
        bool? result = await DialogService.ShowMessageBox("Finished", (MarkupString) "All images have been marked.", yesText: "Commit", noText: "Cancel", cancelText: "Stay");

        switch (result)
        {
            case true:
            {
                var filterResult = new FilterResult
                {
                    Choices = new(_choices)
                };

                await OnFilterComplete.InvokeAsync(filterResult);
                await OnClose.InvokeAsync();

                break;
            }
            case false: await OnClose.InvokeAsync(); break;
            default:
            {
                if (undoLast && CurrentImage is not null)
                {
                    _choices.Remove(CurrentImage);
                }

                break;
            }
        }
    }

    private bool IsValidIndex<T>(List<T> list, int index) => index >= 0 && index < list.Count;

    public void Dispose()
    {
        ShellService.ShowShell();
    }

    public enum FilterChoice
    {
        Archive,
        Delete
    }

    public sealed class FilterResult
    {
        public required Dictionary<string, FilterChoice> Choices { get; init; }
    }

}

<style>
    .image-viewer {
        display: flex;
        flex-direction: column;
        background: var(--background-color);
        justify-items: center;
        height: 100vh;
        width: 100vw;
        overflow: hidden;
    }

    .media-plane {
        display: flex;
        flex-direction: row;
        justify-content: flex-start;

        padding: 0.3rem;
        flex: 1 1 0;
        min-height: 0;

    }

    .tag-list {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        max-width: 10%;
    }

    .image-display {
        overflow-x: visible;
    }

    img {
        object-fit: contain;
        display: block;
        margin: auto;
        max-height: 100%;
        max-width: 100%;
        height: auto;
        width: auto;
    }

    .toolbar {
        display: flex;
        flex-direction: row;
        gap: 1em;
        align-items: center;
        border-bottom: 1px solid;
    }
</style>