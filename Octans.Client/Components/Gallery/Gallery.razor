@page "/gallery"
@using Octans.Client.Components.Pages
@inject GalleryViewmodel Viewmodel
@implements IAsyncDisposable

<MudPopover
    Open="@(Viewmodel.CurrentImage is not null)"
    Fixed="true"
    TransformOrigin="Origin.TopCenter"
    AnchorOrigin="Origin.TopCenter"
    Class="image-popover">
    <ImageViewer
        ImageUrls="Viewmodel.ImageUrls"
        StartingImage="@Viewmodel.CurrentImage"
        FilterMode="Viewmodel.FilterMode"
        OnClose="@OnClose"
        OnFilterComplete="@Viewmodel.OnFilterComplete"/>
</MudPopover>

<SplitContainer
    UnitOfPaneSize="UnitOfPaneSize.Percent"
    @bind-FirstPaneSize="PaneSize"
    Orientation="SplitterOrientation.Vertical">

    <FirstPane>
        <section class="querying">
            <GallerySidebar/>
        </section>
    </FirstPane>

    <SecondPane>
        <div class="gallery-container">
            @if (Viewmodel.ImageUrls.Any())
            {
                <div class="image-grid">
                    @foreach (var url in Viewmodel.ImageUrls)
                    {
                        <div class="image-card"
                             @ondblclick="@(() => Viewmodel.CurrentImage = url)"
                             @onclick="@(() => SetSelectedImage(url))">
                            <MudMenu ActivationEvent="MouseEvent.RightClick" PositionAtCursor="true">
                                <ActivatorContent>
                                    <img src="@url"
                                         alt="Gallery image"
                                         loading="lazy"
                                         decoding="async"
                                         referrerpolicy="no-referrer"/>
                                </ActivatorContent>
                                <ChildContent>
                                    @foreach (var menuItem in Viewmodel.ContextMenuItems)
                                    {
                                        @if (menuItem.HasSubItems)
                                        {
                                            <MudMenu Icon="@menuItem.Icon">
                                                <ActivatorContent>
                                                    <MudMenuItem Icon="@menuItem.Icon">
                                                        @menuItem.Text
                                                        <MudIcon Icon="Icons.Material.Filled.ChevronRight"
                                                                 Style="margin-left: auto;"/>
                                                    </MudMenuItem>
                                                </ActivatorContent>
                                                <ChildContent>
                                                    @foreach (var subItem in menuItem.SubItems!)
                                                    {
                                                        <MudMenuItem Icon="@subItem.Icon"
                                                                     OnClick="@(() => subItem.Action!(new List<string>
                                                                              {
                                                                                  url
                                                                              }))">
                                                            @subItem.Text
                                                        </MudMenuItem>
                                                    }
                                                </ChildContent>
                                            </MudMenu>
                                        }
                                        else
                                        {
                                            <MudMenuItem
                                                Icon="@menuItem.Icon"
                                                Disabled="@(menuItem.Action is null)"
                                                OnClick="@(() => menuItem.Action!(new List<string>
                                                         {
                                                             url
                                                         }))">
                                                @menuItem.Text
                                            </MudMenuItem>
                                        }
                                    }
                                </ChildContent>
                            </MudMenu>
                        </div>
                    }
                </div>
            }
            else if (!string.IsNullOrWhiteSpace(Viewmodel.LastError))
            {
                <p>@Viewmodel.LastError</p>
            }
            else if (Viewmodel.Searching)
            {
                <!-- TODO: put in a status bar in a layout. -->

                <MudProgressCircular Color="Color.Primary" Value="@Viewmodel.ProgressPercent" Size="Size.Large">
                    <ChildContent>
                        @Viewmodel.ProgressPercent %
                    </ChildContent>
                </MudProgressCircular>
            }
            else
            {
                <p>No images found.</p>
            }
        </div>
    </SecondPane>
</SplitContainer>

@code
{
    public int PaneSize { get; private set; } = 30;

    protected override async Task OnInitializedAsync()
    {
        if (RendererInfo.IsInteractive)
        {
            Viewmodel.StateChanged += OnViewmodelOnStateChanged;
            await Viewmodel.OnInitialized();
        }
    }

    private async Task OnViewmodelOnStateChanged()
    {
        await InvokeAsync(StateHasChanged);
    }

    private async Task SetSelectedImage(string url)
    {
        // Extract hex from url: /media/{hex}
        var hex = url[(url.LastIndexOf('/') + 1)..];
        Viewmodel.SelectedImageHash = hex;
        // Trigger state change so sidebar updates
        await Viewmodel.NotifyStateChanged();
        // Trigger local state change to highlight selection if implemented (or just to be safe)
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        if (RendererInfo.IsInteractive)
        {
            Viewmodel.StateChanged -= OnViewmodelOnStateChanged;
            await Viewmodel.DisposeAsync();
        }
    }

    private void OnClose()
    {
        Viewmodel.CurrentImage = null;
        Viewmodel.FilterMode = false;
    }
}
