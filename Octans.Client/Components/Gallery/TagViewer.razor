<div class="tag-viewer">
    <h3>selection tags</h3>

    <div class="selection-tag-buttons">
        <MudSelect T="SortMode" Label="sort by" Dense="true" @bind-Value="Sort">
            @foreach (var v in Enum.GetValues<SortMode>())
            {
                <MudSelectItem Value="v">@v.ToString()</MudSelectItem>
            }
        </MudSelect>

        <MudSelect T="AlphabeticOrdering" Label="alphabetical" Dense="true" @bind-Value="Ordering">
            @foreach (var v in Enum.GetValues<AlphabeticOrdering>())
            {
                <MudSelectItem Value="v">@v.ToString()</MudSelectItem>
            }
        </MudSelect>

        <MudSelect T="GroupingMode" Label="grouping" Dense="true" @bind-Value="Grouping">
            @foreach (var v in Enum.GetValues<GroupingMode>())
            {
                <MudSelectItem Value="v">@v.ToString()</MudSelectItem>
            }
        </MudSelect>
    </div>

    <MudPaper Class="tag-list" Elevation="1" Outlined="true">
        <MudList
            T="string"
            Dense="true"
            SelectionMode="SelectionMode.MultiSelection"
            SelectedValues="SelectedTags"
            SelectedValuesChanged="SelectedTagsChanged"
        >
            @if (GroupedTags != null)
            {
                @foreach (var group in GroupedTags)
                {
                    <MudListSubheader>@group.Key</MudListSubheader>
                    @foreach (var tag in group)
                    {
                        <MudListItem Value="@tag" Class="tag-list-item">
                            <MudText Typo="Typo.body2">@tag</MudText>
                        </MudListItem>
                    }
                }
            }
            else
            {
                @foreach (var tag in Ordered)
                {
                    <MudListItem Value="@tag" Class="tag-list-item">
                        <MudText Typo="Typo.body2">@tag</MudText>
                    </MudListItem>
                }
            }
        </MudList>
    </MudPaper>
</div>

@code {
    [Parameter, EditorRequired] public List<Tag> Tags { get; set; } = [];

    [Parameter] public IReadOnlyCollection<string>? SelectedTags { get; set; }
    [Parameter] public EventCallback<IReadOnlyCollection<string>?> SelectedTagsChanged { get; set; }

    private List<Tag> Ordered { get; set; } = [];
    private IEnumerable<IGrouping<string, Tag>>? GroupedTags { get; set; }

    protected override void OnParametersSet()
    {
        var tags = Tags.ToList();

        // 1. Sort items
        if (Sort == SortMode.ByTag)
        {
            tags = tags.OrderBy(s => s.Namespace).ThenBy(s => s.Subtag).ToList();
        }
        else if (Sort == SortMode.BySubtag)
        {
            tags = tags.OrderBy(s => s.Subtag).ToList();
        }
        else if (Sort == SortMode.ByCount)
        {
            tags = tags.OrderBy(s => s.Count).ToList();
        }

        // 2. Apply Ordering (Reverse if needed)
        if (Ordering == AlphabeticOrdering.Reversed)
        {
            tags.Reverse();
        }

        // 3. Grouping
        if (Grouping == GroupingMode.None)
        {
            Ordered = tags;
            GroupedTags = null;
        }
        else
        {
            // Group by Namespace
            // We use the already sorted/reversed list 'tags', so items within groups preserve their relative order.
            var groups = tags.GroupBy(t => t.Namespace);

            if (Grouping == GroupingMode.NamespaceAlphabetic)
            {
                // Sort groups by Key (Namespace)
                if (Ordering == AlphabeticOrdering.Reversed)
                    groups = groups.OrderByDescending(g => g.Key);
                else
                    groups = groups.OrderBy(g => g.Key);
            }
            // NamespaceUser: We don't have user order, so we rely on the implicit order (order of appearance).

            GroupedTags = groups.ToList();
            Ordered = [];
        }
    }

    public SortMode Sort { get; set; }
    public AlphabeticOrdering Ordering { get; set; }
    public GroupingMode Grouping { get; set; }

    public record Tag(string Namespace, string Subtag, int Count);

    public enum SortMode
    {
        ByTag,
        BySubtag,
        ByCount
    }

    public enum AlphabeticOrdering
    {
        Normal,
        Reversed
    }

    public enum GroupingMode
    {
        None,
        NamespaceAlphabetic,
        NamespaceUser
    }

}

<style>
    .tag-viewer {
        display: flex;
        flex-direction: column;
        gap: 1em;
        align-items: center;
    }

    .selection-tag-buttons {
        display: flex;
        flex-direction: row;
        gap: .5rem;
    }

    .tag-list {
        width: 100%;
        min-height: 50%;
        overflow-y: auto;
        border: 1px solid black;
    }

    /* make each item take the full row and left-align text */
    .tag-list-item {
        width: 100%;
        justify-content: flex-start;
        text-align: left;
        padding-left: .5rem;
    }
</style>